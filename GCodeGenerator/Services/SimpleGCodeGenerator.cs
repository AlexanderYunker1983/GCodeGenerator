using System.Collections.Generic;
using GCodeGenerator.Models;

namespace GCodeGenerator.Services
{
    /// <summary>
    /// Very simple generator just to have end-to-end flow working.
    /// Later it can be replaced with a more advanced implementation.
    /// </summary>
    public class SimpleGCodeGenerator : IGCodeGenerator
    {
        public GCodeProgram Generate(IList<OperationBase> operations, GCodeSettings settings)
        {
            var program = new GCodeProgram();
            var lineNumber = settings.UseLineNumbers ? settings.LineNumberStart : 0;

            void AddLine(string code)
            {
                if (settings.UseLineNumbers)
                {
                    program.Lines.Add($"N{lineNumber} {code}");
                    lineNumber += settings.LineNumberStep;
                }
                else
                {
                    program.Lines.Add(code);
                }
            }

            AddLine("(Generated by GCodeGenerator)");

            foreach (var operation in operations)
            {
                if (settings.UseComments)
                    AddLine($"({operation.Name}: {operation.GetDescription()})");

                if (operation is DrillPointsOperation drill)
                {
                    var fmt = $"0.{new string('#', drill.Decimals)}";

                    foreach (var hole in drill.Holes)
                    {
                        // 1. Move to XY of the hole using rapid feed (assume we are already at safe Z).
                        AddLine($"G0 X{hole.X.ToString(fmt)} Y{hole.Y.ToString(fmt)} F{drill.FeedXYRapid.ToString(fmt)}");

                        // 2. Peck drilling by StepDepth until TotalDepth is reached.
                        var currentZ = hole.Z;
                        var finalZ = hole.Z - hole.TotalDepth;

                        while (currentZ > finalZ)
                        {
                            var nextZ = currentZ - hole.StepDepth;
                            if (nextZ < finalZ)
                                nextZ = finalZ;

                            // Rapid to current start Z, then work feed to next depth.
                            AddLine($"G0 Z{currentZ.ToString(fmt)} F{hole.FeedZRapid.ToString(fmt)}");
                            AddLine($"G1 Z{nextZ.ToString(fmt)} F{hole.FeedZWork.ToString(fmt)}");

                            currentZ = nextZ;

                            // Retract only if we have more depth to drill.
                            if (currentZ > finalZ)
                                AddLine($"G0 Z{hole.RetractHeight.ToString(fmt)} F{hole.FeedZRapid.ToString(fmt)}");
                        }

                        // 3. After finishing the hole, move back to safe Z for travel to next hole.
                        AddLine($"G0 Z{drill.SafeZBetweenHoles.ToString(fmt)} F{hole.FeedZRapid.ToString(fmt)}");
                    }
                }
                else
                {
                    // Stub for other types
                    AddLine($"; TODO: implement {operation.Type} generation");
                }
            }

            AddLine("M30");
            return program;
        }
    }
}


