using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using GCodeGenerator.Models;

namespace GCodeGenerator.Services
{
    /// <summary>
    /// Very simple generator just to have end-to-end flow working.
    /// Later it can be replaced with a more advanced implementation.
    /// </summary>
    public class SimpleGCodeGenerator : IGCodeGenerator
    {
        public GCodeProgram Generate(IList<OperationBase> operations, GCodeSettings settings)
        {
            var program = new GCodeProgram();
            var lineNumber = settings.UseLineNumbers ? settings.LineNumberStart : 0;
            string FormatG(string code)
            {
                if (!settings.UsePaddedGCodes)
                    return code;
                if (code.Length >= 2 && code[0] == 'G')
                {
                    if (int.TryParse(code.Substring(1), out var n))
                        return $"G{n:00}";
                }
                return code;
            }

            var g0 = FormatG("G0");
            var g1 = FormatG("G1");

            void AddLine(string code)
            {
                if (settings.UseLineNumbers)
                {
                    program.Lines.Add($"N{lineNumber} {code}");
                    lineNumber += settings.LineNumberStep;
                }
                else
                {
                    program.Lines.Add(code);
                }
            }

            AddLine("(Generated by GCodeGenerator)");

            foreach (var operation in operations)
            {
                if (settings.UseComments)
                    AddLine($"({operation.Name}: {operation.GetDescription()})");

                if (operation is DrillPointsOperation drill)
                {
                    // Use '0' instead of '#' to always show specified decimal places, even for zeros
                    var fmt = $"0.{new string('0', drill.Decimals)}";
                    var culture = CultureInfo.InvariantCulture;

                    foreach (var hole in drill.Holes)
                    {
                        // 1. Move to safe Z first, then to XY of the hole using rapid feed.
                        AddLine($"{g0} Z{drill.SafeZBetweenHoles.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                        AddLine($"{g0} X{hole.X.ToString(fmt, culture)} Y{hole.Y.ToString(fmt, culture)} F{drill.FeedXYRapid.ToString(fmt, culture)}");

                        // 2. Peck drilling by StepDepth until TotalDepth is reached.
                        var currentZ = hole.Z;
                        var finalZ = hole.Z - hole.TotalDepth;

                        while (currentZ > finalZ)
                        {
                            var nextZ = currentZ - hole.StepDepth;
                            if (nextZ < finalZ)
                                nextZ = finalZ;

                            // Rapid to current start Z, then work feed to next depth.
                            AddLine($"{g0} Z{currentZ.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                            AddLine($"{g1} Z{nextZ.ToString(fmt, culture)} F{hole.FeedZWork.ToString(fmt, culture)}");

                            currentZ = nextZ;

                            // Retract only if we have more depth to drill.
                            if (currentZ > finalZ)
                                AddLine($"{g0} Z{hole.RetractHeight.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                        }

                        // 3. After finishing the hole, move back to safe Z for travel to next hole.
                        AddLine($"{g0} Z{drill.SafeZBetweenHoles.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                    }
                }
                else if (operation is ProfileRectangleOperation profileRect)
                {
                    GenerateProfileRectangle(profileRect, AddLine, g0, g1, settings);
                }
                else if (operation is ProfileCircleOperation profileCircle)
                {
                    GenerateProfileCircle(profileCircle, AddLine, g0, g1, settings);
                }
                else
                {
                    // Stub for other types
                    AddLine($"; TODO: implement {operation.Type} generation");
                }
            }

            AddLine("M30");
            return program;
        }

        private void GenerateProfileRectangle(ProfileRectangleOperation op, Action<string> addLine, string g0, string g1, GCodeSettings settings)
        {
            var fmt = $"0.{new string('0', op.Decimals)}";
            var culture = CultureInfo.InvariantCulture;

            // Calculate tool radius offset
            var toolRadius = op.ToolDiameter / 2.0;
            var offset = 0.0;
            if (op.ToolPathMode == ToolPathMode.Outside)
                offset = toolRadius;
            else if (op.ToolPathMode == ToolPathMode.Inside)
                offset = -toolRadius;

            // Calculate center point based on reference point type
            double centerX, centerY;
            switch (op.ReferencePointType)
            {
                case ReferencePointType.Center:
                    centerX = op.ReferencePointX;
                    centerY = op.ReferencePointY;
                    break;
                case ReferencePointType.TopLeft:
                    centerX = op.ReferencePointX + op.Width / 2.0;
                    centerY = op.ReferencePointY - op.Height / 2.0;
                    break;
                case ReferencePointType.TopRight:
                    centerX = op.ReferencePointX - op.Width / 2.0;
                    centerY = op.ReferencePointY - op.Height / 2.0;
                    break;
                case ReferencePointType.BottomLeft:
                    centerX = op.ReferencePointX + op.Width / 2.0;
                    centerY = op.ReferencePointY + op.Height / 2.0;
                    break;
                case ReferencePointType.BottomRight:
                    centerX = op.ReferencePointX - op.Width / 2.0;
                    centerY = op.ReferencePointY + op.Height / 2.0;
                    break;
                default:
                    centerX = op.ReferencePointX;
                    centerY = op.ReferencePointY;
                    break;
            }

            // Calculate rectangle corners (before rotation and offset)
            var halfWidth = op.Width / 2.0 + offset;
            var halfHeight = op.Height / 2.0 + offset;

            var corners = new[]
            {
                new { X = -halfWidth, Y = -halfHeight },  // 0: Bottom-left (relative to center)
                new { X = halfWidth, Y = -halfHeight },   // 1: Bottom-right
                new { X = halfWidth, Y = halfHeight },     // 2: Top-right
                new { X = -halfWidth, Y = halfHeight }     // 3: Top-left
            };

            // Apply rotation
            var angleRad = op.RotationAngle * Math.PI / 180.0;
            var cos = Math.Cos(angleRad);
            var sin = Math.Sin(angleRad);

            var rotatedCorners = corners.Select(c =>
            {
                var x = c.X * cos - c.Y * sin;
                var y = c.X * sin + c.Y * cos;
                return new { X = centerX + x, Y = centerY + y };
            }).ToArray();

            // Determine corner order based on direction
            // Clockwise (viewed from above): 0->3->2->1 (Bottom-left -> Top-left -> Top-right -> Bottom-right)
            // Counter-clockwise: 0->1->2->3 (Bottom-left -> Bottom-right -> Top-right -> Top-left)
            int[] cornerOrder;
            if (op.Direction == MillingDirection.Clockwise)
            {
                cornerOrder = new[] { 0, 3, 2, 1 }; // Clockwise: BL -> TL -> TR -> BR
            }
            else
            {
                cornerOrder = new[] { 0, 1, 2, 3 }; // Counter-clockwise: BL -> BR -> TR -> TL
            }

            // Generate depth passes
            // currentZ represents already processed depth (or contour height if first pass)
            var currentZ = op.ContourHeight;
            var finalZ = op.ContourHeight - op.TotalDepth;
            var passNumber = 0;

            while (currentZ > finalZ)
            {
                var nextZ = currentZ - op.StepDepth;
                if (nextZ < finalZ)
                    nextZ = finalZ;

                passNumber++;

                if (settings.UseComments)
                    addLine($"(Pass {passNumber}, depth {nextZ.ToString(fmt, culture)})");

                // Move to safe Z and then to start position (all at safe height)
                var startCorner = rotatedCorners[cornerOrder[0]];
                addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                addLine($"{g0} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYRapid.ToString(fmt, culture)}");

                // Entry move
                if (op.EntryMode == EntryMode.Vertical)
                {
                    // Vertical entry: rapid to already processed depth, then work feed to target depth
                    addLine($"{g0} Z{currentZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    addLine($"{g1} Z{nextZ.ToString(fmt, culture)} F{op.FeedZWork.ToString(fmt, culture)}");
                }
                else
                {
                    // Angled entry: drop to retract height (from already processed depth), then ramp down along the contour
                    var entryAngleRad = op.EntryAngle * Math.PI / 180.0;
                    
                    // Retract height is relative to already processed depth
                    // currentZ = already processed depth (or contour height if first pass)
                    // retractZ = currentZ + RetractHeight (above processed depth by retract height)
                    var retractZ = currentZ + op.RetractHeight;
                    
                    // Drop to retract height (above the already processed depth)
                    addLine($"{g0} Z{retractZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    
                    // Ramp with constant angle along the contour
                    // Start from retract height and move along contour maintaining the entry angle
                    var rampStartZ = retractZ;
                    var rampEndZ = nextZ;
                    var tanAngle = Math.Tan(entryAngleRad);
                    
                    // Current position during ramp
                    var rampCurrentZ = rampStartZ;
                    var rampCurrentX = startCorner.X;
                    var rampCurrentY = startCorner.Y;
                    var totalDistanceTraveled = 0.0;
                    var edgeIndex = 0;
                    var rampComplete = false;
                    
                    // Move along contour maintaining the entry angle
                    while (!rampComplete && edgeIndex < cornerOrder.Length)
                    {
                        var edgeStart = rotatedCorners[cornerOrder[edgeIndex]];
                        var edgeEnd = rotatedCorners[cornerOrder[(edgeIndex + 1) % cornerOrder.Length]];
                        var edgeDx = edgeEnd.X - edgeStart.X;
                        var edgeDy = edgeEnd.Y - edgeStart.Y;
                        var edgeLength = Math.Sqrt(edgeDx * edgeDx + edgeDy * edgeDy);
                        
                        if (edgeLength > 0.001)
                        {
                            var edgeDirX = edgeDx / edgeLength;
                            var edgeDirY = edgeDy / edgeLength;
                            
                            // Calculate how far we can travel on this edge before reaching target depth
                            // newZ = rampStartZ - (totalDistanceTraveled + distanceOnEdge) * tan(angle)
                            // We want newZ = rampEndZ
                            // So: rampEndZ = rampStartZ - (totalDistanceTraveled + distanceOnEdge) * tan(angle)
                            // distanceOnEdge = (rampStartZ - rampEndZ - totalDistanceTraveled * tan(angle)) / tan(angle)
                            // distanceOnEdge = (rampDepth - totalDistanceTraveled * tan(angle)) / tan(angle)
                            var remainingDepth = rampStartZ - rampEndZ - totalDistanceTraveled * tanAngle;
                            
                            if (remainingDepth <= 0)
                            {
                                // Already reached target depth
                                rampComplete = true;
                                break;
                            }
                            
                            var maxDistanceOnEdge = remainingDepth / tanAngle;
                            
                            if (maxDistanceOnEdge >= edgeLength)
                            {
                                // Can travel entire edge, but won't reach target depth yet
                                // Calculate Z at end of edge
                                var newZ = rampStartZ - (totalDistanceTraveled + edgeLength) * tanAngle;
                                if (newZ < rampEndZ) newZ = rampEndZ;
                                
                                // Move to end of edge
                                addLine($"{g1} X{edgeEnd.X.ToString(fmt, culture)} Y{edgeEnd.Y.ToString(fmt, culture)} Z{newZ.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                                
                                rampCurrentX = edgeEnd.X;
                                rampCurrentY = edgeEnd.Y;
                                rampCurrentZ = newZ;
                                totalDistanceTraveled += edgeLength;
                                
                                // Check if we reached target depth
                                if (Math.Abs(newZ - rampEndZ) < 0.001)
                                {
                                    rampComplete = true;
                                    break;
                                }
                                
                                edgeIndex++;
                            }
                            else
                            {
                                // Will reach target depth on this edge
                                // Calculate position from edge start
                                var finalX = edgeStart.X + edgeDirX * maxDistanceOnEdge;
                                var finalY = edgeStart.Y + edgeDirY * maxDistanceOnEdge;
                                
                                // Move to point where we reach target depth
                                addLine($"{g1} X{finalX.ToString(fmt, culture)} Y{finalY.ToString(fmt, culture)} Z{rampEndZ.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                                
                                rampCurrentX = finalX;
                                rampCurrentY = finalY;
                                rampCurrentZ = rampEndZ;
                                rampComplete = true;
                                break;
                            }
                        }
                        else
                        {
                            // Edge has zero length, skip to next
                            edgeIndex++;
                        }
                    }
                    
                    // After ramp reached target depth, lift to safe height and move to start corner
                    addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    addLine($"{g0} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYRapid.ToString(fmt, culture)}");
                    
                    // Drop to target depth
                    addLine($"{g0} Z{nextZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    
                    // Now mill the entire contour at target depth (including the ramp section)
                    for (int i = 1; i < cornerOrder.Length; i++)
                    {
                        var corner = rotatedCorners[cornerOrder[i]];
                        addLine($"{g1} X{corner.X.ToString(fmt, culture)} Y{corner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                    }
                    
                    // Close the contour (return to start)
                    addLine($"{g1} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                    
                    // Contour is now complete, skip regular contour milling
                }

                // Mill the contour (only if not already completed during angled entry)
                // For vertical entry, always mill the contour
                // For angled entry, contour is already completed during ramp, so skip
                if (op.EntryMode == EntryMode.Vertical)
                {
                    // Mill the contour
                    for (int i = 1; i < cornerOrder.Length; i++)
                    {
                        var corner = rotatedCorners[cornerOrder[i]];
                        addLine($"{g1} X{corner.X.ToString(fmt, culture)} Y{corner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                    }
                    
                    // Close the contour (return to start)
                    addLine($"{g1} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                }
                // For angled entry, contour is already completed during ramp, so no need to mill it again

                // Retract (only if there are more passes to do)
                if (nextZ > finalZ)
                {
                    // Retract to height above the depth we just processed
                    var retractZAfterPass = nextZ + op.RetractHeight;
                    addLine($"{g0} Z{retractZAfterPass.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                }

                // Update currentZ to the depth we just processed for the next pass
                currentZ = nextZ;
            }

            // Final retract to safe Z
            addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
        }

        private void GenerateProfileCircle(ProfileCircleOperation op, Action<string> addLine, string g0, string g1, GCodeSettings settings)
        {
            var fmt = $"0.{new string('0', op.Decimals)}";
            var culture = CultureInfo.InvariantCulture;

            // Calculate tool radius offset
            var toolRadius = op.ToolDiameter / 2.0;
            var offset = 0.0;
            if (op.ToolPathMode == ToolPathMode.Outside)
                offset = toolRadius;
            else if (op.ToolPathMode == ToolPathMode.Inside)
                offset = -toolRadius;

            // Calculate actual radius for tool path
            var actualRadius = op.Radius + offset;

            // Generate depth passes
            var currentZ = op.ContourHeight;
            var finalZ = op.ContourHeight - op.TotalDepth;
            var passNumber = 0;

            // Calculate start point on circle (at angle 0, which is right side)
            var startX = op.CenterX + actualRadius;
            var startY = op.CenterY;

            while (currentZ > finalZ)
            {
                var nextZ = currentZ - op.StepDepth;
                if (nextZ < finalZ)
                    nextZ = finalZ;

                passNumber++;

                if (settings.UseComments)
                    addLine($"(Pass {passNumber}, depth {nextZ.ToString(fmt, culture)})");

                // Move to safe Z and then to start position
                addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                addLine($"{g0} X{startX.ToString(fmt, culture)} Y{startY.ToString(fmt, culture)} F{op.FeedXYRapid.ToString(fmt, culture)}");

                // Entry move
                if (op.EntryMode == EntryMode.Vertical)
                {
                    // Vertical entry: rapid to already processed depth, then work feed to target depth
                    addLine($"{g0} Z{currentZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    addLine($"{g1} Z{nextZ.ToString(fmt, culture)} F{op.FeedZWork.ToString(fmt, culture)}");
                }
                else
                {
                    // Angled entry: ramp down along the circle
                    var entryAngleRad = op.EntryAngle * Math.PI / 180.0;
                    var retractZ = currentZ + op.RetractHeight;
                    
                    addLine($"{g0} Z{retractZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    
                    // Calculate ramp distance needed
                    var rampDepth = retractZ - nextZ;
                    var rampDistance = rampDepth / Math.Tan(entryAngleRad);
                    
                    // Calculate angle increment for ramp
                    var circumference = 2 * Math.PI * actualRadius;
                    var angleForRamp = (rampDistance / circumference) * 2 * Math.PI;
                    
                    // Start angle (0 = right side)
                    var rampStartAngle = 0.0;
                    var rampEndAngle = angleForRamp;
                    if (op.Direction == MillingDirection.Clockwise)
                        rampEndAngle = -angleForRamp;
                    
                    // Generate ramp points
                    var rampSegments = Math.Max(4, (int)(Math.Abs(angleForRamp) / (Math.PI / 16)));
                    for (int i = 1; i <= rampSegments; i++)
                    {
                        var t = (double)i / rampSegments;
                        var angle = rampStartAngle + t * rampEndAngle;
                        var x = op.CenterX + actualRadius * Math.Cos(angle);
                        var y = op.CenterY + actualRadius * Math.Sin(angle);
                        var z = retractZ - t * rampDepth;
                        
                        addLine($"{g1} X{x.ToString(fmt, culture)} Y{y.ToString(fmt, culture)} Z{z.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                    }
                    
                    // After ramp, lift to safe height and move to start
                    addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    addLine($"{g0} X{startX.ToString(fmt, culture)} Y{startY.ToString(fmt, culture)} F{op.FeedXYRapid.ToString(fmt, culture)}");
                    addLine($"{g0} Z{nextZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                }

                // Mill the circle contour
                if (settings.AllowArcs)
                {
                    // Use arc commands (G2/G3)
                    var g2 = settings.UsePaddedGCodes ? "G02" : "G2";
                    var g3 = settings.UsePaddedGCodes ? "G03" : "G3";
                    
                    // I and J are offsets from current position to center
                    var i = op.CenterX - startX;
                    var j = op.CenterY - startY;
                    
                    // Use G2 for clockwise, G3 for counter-clockwise
                    var arcCommand = op.Direction == MillingDirection.Clockwise ? g2 : g3;
                    
                    // Split full circle into two semicircles to avoid issues with some controllers
                    // First semicircle: from start (right) to opposite point (left)
                    var midX = op.CenterX - actualRadius;
                    var midY = op.CenterY;
                    addLine($"{arcCommand} X{midX.ToString(fmt, culture)} Y{midY.ToString(fmt, culture)} I{i.ToString(fmt, culture)} J{j.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                    
                    // Second semicircle: from mid point back to start
                    var i2 = op.CenterX - midX;
                    var j2 = op.CenterY - midY;
                    addLine($"{arcCommand} X{startX.ToString(fmt, culture)} Y{startY.ToString(fmt, culture)} I{i2.ToString(fmt, culture)} J{j2.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                }
                else
                {
                    // Approximate circle with linear segments
                    // Calculate number of segments based on max segment length
                    var circumference = 2 * Math.PI * actualRadius;
                    var numSegments = Math.Max(4, (int)Math.Ceiling(circumference / op.MaxSegmentLength));
                    var angleStep = 2 * Math.PI / numSegments;
                    
                    if (op.Direction == MillingDirection.Clockwise)
                        angleStep = -angleStep;
                    
                    // Generate segments
                    for (int i = 1; i <= numSegments; i++)
                    {
                        var angle = i * angleStep;
                        var x = op.CenterX + actualRadius * Math.Cos(angle);
                        var y = op.CenterY + actualRadius * Math.Sin(angle);
                        
                        addLine($"{g1} X{x.ToString(fmt, culture)} Y{y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                    }
                }

                // Retract (only if there are more passes to do)
                if (nextZ > finalZ)
                {
                    var retractZAfterPass = nextZ + op.RetractHeight;
                    addLine($"{g0} Z{retractZAfterPass.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                }

                // Update currentZ to the depth we just processed for the next pass
                currentZ = nextZ;
            }

            // Final retract to safe Z
            addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
        }
    }
}


