using System.Collections.Generic;
using GCodeGenerator.Models;

namespace GCodeGenerator.Services
{
    /// <summary>
    /// Very simple generator just to have end-to-end flow working.
    /// Later it can be replaced with a more advanced implementation.
    /// </summary>
    public class SimpleGCodeGenerator : IGCodeGenerator
    {
        public GCodeProgram Generate(IList<OperationBase> operations, GCodeSettings settings)
        {
            var program = new GCodeProgram();
            var lineNumber = settings.UseLineNumbers ? settings.LineNumberStart : 0;

            void AddLine(string code)
            {
                if (settings.UseLineNumbers)
                {
                    program.Lines.Add($"N{lineNumber} {code}");
                    lineNumber += settings.LineNumberStep;
                }
                else
                {
                    program.Lines.Add(code);
                }
            }

            AddLine("(Generated by GCodeGenerator)");

            foreach (var operation in operations)
            {
                if (settings.UseComments)
                    AddLine($"({operation.Name}: {operation.GetDescription()})");

                if (operation is DrillPointsOperation drill)
                {
                    // Very primitive drill cycle using G0/G1
                    foreach (var pt in drill.Points)
                    {
                        AddLine($"G0 X{pt.X:0.###} Y{pt.Y:0.###} Z{drill.SafeZ:0.###}");
                        AddLine($"G1 Z{drill.DrillZ:0.###} F{drill.Feed:0.###}");
                        AddLine($"G0 Z{drill.SafeZ:0.###}");
                    }
                }
                else
                {
                    // Stub for other types
                    AddLine($"; TODO: implement {operation.Type} generation");
                }
            }

            AddLine("M30");
            return program;
        }
    }
}


