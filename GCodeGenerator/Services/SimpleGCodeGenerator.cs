using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using GCodeGenerator.Models;

namespace GCodeGenerator.Services
{
    /// <summary>
    /// Very simple generator just to have end-to-end flow working.
    /// Later it can be replaced with a more advanced implementation.
    /// </summary>
    public class SimpleGCodeGenerator : IGCodeGenerator
    {
        public GCodeProgram Generate(IList<OperationBase> operations, GCodeSettings settings)
        {
            var program = new GCodeProgram();
            var lineNumber = settings.UseLineNumbers ? settings.LineNumberStart : 0;
            string FormatG(string code)
            {
                if (!settings.UsePaddedGCodes)
                    return code;
                if (code.Length >= 2 && code[0] == 'G')
                {
                    if (int.TryParse(code.Substring(1), out var n))
                        return $"G{n:00}";
                }
                return code;
            }

            var g0 = FormatG("G0");
            var g1 = FormatG("G1");

            void AddLine(string code)
            {
                if (settings.UseLineNumbers)
                {
                    program.Lines.Add($"N{lineNumber} {code}");
                    lineNumber += settings.LineNumberStep;
                }
                else
                {
                    program.Lines.Add(code);
                }
            }

            AddLine("(Generated by GCodeGenerator)");

            foreach (var operation in operations)
            {
                if (settings.UseComments)
                    AddLine($"({operation.Name}: {operation.GetDescription()})");

                if (operation is DrillPointsOperation drill)
                {
                    // Use '0' instead of '#' to always show specified decimal places, even for zeros
                    var fmt = $"0.{new string('0', drill.Decimals)}";
                    var culture = CultureInfo.InvariantCulture;

                    foreach (var hole in drill.Holes)
                    {
                        // 1. Move to safe Z first, then to XY of the hole using rapid feed.
                        AddLine($"{g0} Z{drill.SafeZBetweenHoles.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                        AddLine($"{g0} X{hole.X.ToString(fmt, culture)} Y{hole.Y.ToString(fmt, culture)} F{drill.FeedXYRapid.ToString(fmt, culture)}");

                        // 2. Peck drilling by StepDepth until TotalDepth is reached.
                        var currentZ = hole.Z;
                        var finalZ = hole.Z - hole.TotalDepth;

                        while (currentZ > finalZ)
                        {
                            var nextZ = currentZ - hole.StepDepth;
                            if (nextZ < finalZ)
                                nextZ = finalZ;

                            // Rapid to current start Z, then work feed to next depth.
                            AddLine($"{g0} Z{currentZ.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                            AddLine($"{g1} Z{nextZ.ToString(fmt, culture)} F{hole.FeedZWork.ToString(fmt, culture)}");

                            currentZ = nextZ;

                            // Retract only if we have more depth to drill.
                            if (currentZ > finalZ)
                                AddLine($"{g0} Z{hole.RetractHeight.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                        }

                        // 3. After finishing the hole, move back to safe Z for travel to next hole.
                        AddLine($"{g0} Z{drill.SafeZBetweenHoles.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                    }
                }
                else if (operation is ProfileRectangleOperation profileRect)
                {
                    GenerateProfileRectangle(profileRect, AddLine, g0, g1, settings);
                }
                else
                {
                    // Stub for other types
                    AddLine($"; TODO: implement {operation.Type} generation");
                }
            }

            AddLine("M30");
            return program;
        }

        private void GenerateProfileRectangle(ProfileRectangleOperation op, Action<string> addLine, string g0, string g1, GCodeSettings settings)
        {
            var fmt = $"0.{new string('0', op.Decimals)}";
            var culture = CultureInfo.InvariantCulture;

            // Calculate tool radius offset
            var toolRadius = op.ToolDiameter / 2.0;
            var offset = 0.0;
            if (op.ToolPathMode == ToolPathMode.Outside)
                offset = toolRadius;
            else if (op.ToolPathMode == ToolPathMode.Inside)
                offset = -toolRadius;

            // Calculate center point based on reference point type
            double centerX, centerY;
            switch (op.ReferencePointType)
            {
                case ReferencePointType.Center:
                    centerX = op.ReferencePointX;
                    centerY = op.ReferencePointY;
                    break;
                case ReferencePointType.TopLeft:
                    centerX = op.ReferencePointX + op.Width / 2.0;
                    centerY = op.ReferencePointY - op.Height / 2.0;
                    break;
                case ReferencePointType.TopRight:
                    centerX = op.ReferencePointX - op.Width / 2.0;
                    centerY = op.ReferencePointY - op.Height / 2.0;
                    break;
                case ReferencePointType.BottomLeft:
                    centerX = op.ReferencePointX + op.Width / 2.0;
                    centerY = op.ReferencePointY + op.Height / 2.0;
                    break;
                case ReferencePointType.BottomRight:
                    centerX = op.ReferencePointX - op.Width / 2.0;
                    centerY = op.ReferencePointY + op.Height / 2.0;
                    break;
                default:
                    centerX = op.ReferencePointX;
                    centerY = op.ReferencePointY;
                    break;
            }

            // Calculate rectangle corners (before rotation and offset)
            var halfWidth = op.Width / 2.0 + offset;
            var halfHeight = op.Height / 2.0 + offset;

            var corners = new[]
            {
                new { X = -halfWidth, Y = -halfHeight },  // 0: Bottom-left (relative to center)
                new { X = halfWidth, Y = -halfHeight },   // 1: Bottom-right
                new { X = halfWidth, Y = halfHeight },     // 2: Top-right
                new { X = -halfWidth, Y = halfHeight }     // 3: Top-left
            };

            // Apply rotation
            var angleRad = op.RotationAngle * Math.PI / 180.0;
            var cos = Math.Cos(angleRad);
            var sin = Math.Sin(angleRad);

            var rotatedCorners = corners.Select(c =>
            {
                var x = c.X * cos - c.Y * sin;
                var y = c.X * sin + c.Y * cos;
                return new { X = centerX + x, Y = centerY + y };
            }).ToArray();

            // Determine corner order based on direction
            // Clockwise (viewed from above): 0->3->2->1 (Bottom-left -> Top-left -> Top-right -> Bottom-right)
            // Counter-clockwise: 0->1->2->3 (Bottom-left -> Bottom-right -> Top-right -> Top-left)
            int[] cornerOrder;
            if (op.Direction == MillingDirection.Clockwise)
            {
                cornerOrder = new[] { 0, 3, 2, 1 }; // Clockwise: BL -> TL -> TR -> BR
            }
            else
            {
                cornerOrder = new[] { 0, 1, 2, 3 }; // Counter-clockwise: BL -> BR -> TR -> TL
            }

            // Generate depth passes
            // currentZ represents already processed depth (or contour height if first pass)
            var currentZ = op.ContourHeight;
            var finalZ = op.ContourHeight - op.TotalDepth;
            var passNumber = 0;

            while (currentZ > finalZ)
            {
                var nextZ = currentZ - op.StepDepth;
                if (nextZ < finalZ)
                    nextZ = finalZ;

                passNumber++;

                if (settings.UseComments)
                    addLine($"(Pass {passNumber}, depth {nextZ.ToString(fmt, culture)})");

                // Move to safe Z and then to start position (all at safe height)
                var startCorner = rotatedCorners[cornerOrder[0]];
                addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                addLine($"{g0} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYRapid.ToString(fmt, culture)}");

                // Entry move
                if (op.EntryMode == EntryMode.Vertical)
                {
                    // Vertical entry: rapid to already processed depth, then work feed to target depth
                    addLine($"{g0} Z{currentZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    addLine($"{g1} Z{nextZ.ToString(fmt, culture)} F{op.FeedZWork.ToString(fmt, culture)}");
                }
                else
                {
                    // Angled entry: drop to retract height (from already processed depth), then ramp down along the contour
                    var entryAngleRad = op.EntryAngle * Math.PI / 180.0;
                    
                    // Retract height is relative to already processed depth
                    // currentZ = already processed depth (or contour height if first pass)
                    // retractZ = currentZ + RetractHeight (above processed depth by retract height)
                    var retractZ = currentZ + op.RetractHeight;
                    
                    // Drop to retract height (above the already processed depth)
                    addLine($"{g0} Z{retractZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    
                    // Calculate ramp: from retract height to cutting depth
                    var rampStartZ = retractZ;
                    var rampEndZ = nextZ;
                    var rampDepth = rampStartZ - rampEndZ;
                    var rampDistance = rampDepth / Math.Tan(entryAngleRad);
                    
                    // Get first edge direction (along the contour)
                    var edge1Start = rotatedCorners[cornerOrder[0]];
                    var edge1End = rotatedCorners[cornerOrder[1]];
                    var edge1Dx = edge1End.X - edge1Start.X;
                    var edge1Dy = edge1End.Y - edge1Start.Y;
                    var edge1Length = Math.Sqrt(edge1Dx * edge1Dx + edge1Dy * edge1Dy);
                    
                    if (edge1Length > 0)
                    {
                        var edge1DirX = edge1Dx / edge1Length;
                        var edge1DirY = edge1Dy / edge1Length;
                        
                        // Check if ramp distance fits on first edge
                        if (rampDistance <= edge1Length)
                        {
                            // Ramp fits on first edge - simple case
                            var entryX = startCorner.X + edge1DirX * rampDistance;
                            var entryY = startCorner.Y + edge1DirY * rampDistance;
                            
                            // Ramp down along the first edge to entry point
                            addLine($"{g1} X{entryX.ToString(fmt, culture)} Y{entryY.ToString(fmt, culture)} Z{rampEndZ.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                            
                            // After ramp reached target depth, lift to safe height and move to start corner
                            addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                            addLine($"{g0} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYRapid.ToString(fmt, culture)}");
                            
                            // Drop to target depth
                            addLine($"{g0} Z{nextZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                            
                            // Now mill the entire contour at target depth (including the ramp section)
                            for (int i = 1; i < cornerOrder.Length; i++)
                            {
                                var corner = rotatedCorners[cornerOrder[i]];
                                addLine($"{g1} X{corner.X.ToString(fmt, culture)} Y{corner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                            }
                            
                            // Close the contour (return to start)
                            addLine($"{g1} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                            
                            // Contour is now complete, skip regular contour milling
                        }
                        else
                        {
                            // Ramp doesn't fit on first edge - continue on next edge(s)
                            var remainingRampDistance = rampDistance;
                            var rampCurrentZ = rampStartZ;
                            var rampCurrentX = startCorner.X;
                            var rampCurrentY = startCorner.Y;
                            var edgeIndex = 0;
                            
                            // Continue ramping along edges until we reach target depth
                            while (remainingRampDistance > 0 && rampCurrentZ > rampEndZ && edgeIndex < cornerOrder.Length)
                            {
                                var edgeStart = rotatedCorners[cornerOrder[edgeIndex]];
                                var edgeEnd = rotatedCorners[cornerOrder[(edgeIndex + 1) % cornerOrder.Length]];
                                var edgeDx = edgeEnd.X - edgeStart.X;
                                var edgeDy = edgeEnd.Y - edgeStart.Y;
                                var edgeLength = Math.Sqrt(edgeDx * edgeDx + edgeDy * edgeDy);
                                
                                if (edgeLength > 0)
                                {
                                    var edgeDirX = edgeDx / edgeLength;
                                    var edgeDirY = edgeDy / edgeLength;
                                    
                                    if (remainingRampDistance <= edgeLength)
                                    {
                                        // Final part of ramp fits on this edge
                                        var finalX = rampCurrentX + edgeDirX * remainingRampDistance;
                                        var finalY = rampCurrentY + edgeDirY * remainingRampDistance;
                                        
                                        // Calculate Z at this point
                                        var distanceUsed = rampDistance - remainingRampDistance;
                                        var depthAtPoint = rampStartZ - (distanceUsed / Math.Tan(entryAngleRad));
                                        if (depthAtPoint < rampEndZ) depthAtPoint = rampEndZ;
                                        
                                        // Ramp to final point
                                        addLine($"{g1} X{finalX.ToString(fmt, culture)} Y{finalY.ToString(fmt, culture)} Z{depthAtPoint.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                                        
                                        rampCurrentX = finalX;
                                        rampCurrentY = finalY;
                                        rampCurrentZ = depthAtPoint;
                                        remainingRampDistance = 0;
                                    }
                                    else
                                    {
                                        // Need to continue on next edge
                                        // Calculate Z when we reach the end of this edge
                                        var distanceUsed = rampDistance - remainingRampDistance;
                                        var depthAtEnd = rampStartZ - ((distanceUsed + edgeLength) / Math.Tan(entryAngleRad));
                                        if (depthAtEnd < rampEndZ) depthAtEnd = rampEndZ;
                                        
                                        // Ramp to end of this edge
                                        addLine($"{g1} X{edgeEnd.X.ToString(fmt, culture)} Y{edgeEnd.Y.ToString(fmt, culture)} Z{depthAtEnd.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                                        
                                        rampCurrentX = edgeEnd.X;
                                        rampCurrentY = edgeEnd.Y;
                                        rampCurrentZ = depthAtEnd;
                                        remainingRampDistance -= edgeLength;
                                        edgeIndex++;
                                    }
                                }
                                else
                                {
                                    // Edge has zero length, skip to next
                                    edgeIndex++;
                                }
                            }
                            
                            // After ramp is complete, ensure we're at target depth (where ramp should end)
                            if (Math.Abs(rampCurrentZ - rampEndZ) > 0.001)
                            {
                                addLine($"{g1} Z{rampEndZ.ToString(fmt, culture)} F{op.FeedZWork.ToString(fmt, culture)}");
                                rampCurrentZ = rampEndZ;
                            }
                            
                            // After ramp reached target depth, lift to safe height and move to start corner
                            addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                            addLine($"{g0} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYRapid.ToString(fmt, culture)}");
                            
                            // Drop to target depth
                            addLine($"{g0} Z{nextZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                            
                            // Now mill the entire contour at target depth (including the ramp section)
                            for (int i = 1; i < cornerOrder.Length; i++)
                            {
                                var corner = rotatedCorners[cornerOrder[i]];
                                addLine($"{g1} X{corner.X.ToString(fmt, culture)} Y{corner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                            }
                            
                            // Close the contour (return to start)
                            addLine($"{g1} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                            
                            // Contour is now complete, skip the regular contour milling below
                        }
                    }
                    else
                    {
                        // Fallback to vertical if edge length is zero
                        addLine($"{g0} Z{nextZ.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                    }
                }

                // Mill the contour (only if not already completed during angled entry)
                // For vertical entry, always mill the contour
                // For angled entry, contour is already completed during ramp, so skip
                if (op.EntryMode == EntryMode.Vertical)
                {
                    // Mill the contour
                    for (int i = 1; i < cornerOrder.Length; i++)
                    {
                        var corner = rotatedCorners[cornerOrder[i]];
                        addLine($"{g1} X{corner.X.ToString(fmt, culture)} Y{corner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                    }
                    
                    // Close the contour (return to start)
                    addLine($"{g1} X{startCorner.X.ToString(fmt, culture)} Y{startCorner.Y.ToString(fmt, culture)} F{op.FeedXYWork.ToString(fmt, culture)}");
                }
                // For angled entry, contour is already completed during ramp, so no need to mill it again

                // Retract (only if there are more passes to do)
                if (nextZ > finalZ)
                {
                    // Retract to height above the depth we just processed
                    var retractZAfterPass = nextZ + op.RetractHeight;
                    addLine($"{g0} Z{retractZAfterPass.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
                }

                // Update currentZ to the depth we just processed for the next pass
                currentZ = nextZ;
            }

            // Final retract to safe Z
            addLine($"{g0} Z{op.SafeZHeight.ToString(fmt, culture)} F{op.FeedZRapid.ToString(fmt, culture)}");
        }
    }
}


