using System.Collections.Generic;
using System.Globalization;
using GCodeGenerator.Models;

namespace GCodeGenerator.Services
{
    /// <summary>
    /// Very simple generator just to have end-to-end flow working.
    /// Later it can be replaced with a more advanced implementation.
    /// </summary>
    public class SimpleGCodeGenerator : IGCodeGenerator
    {
        public GCodeProgram Generate(IList<OperationBase> operations, GCodeSettings settings)
        {
            var program = new GCodeProgram();
            var lineNumber = settings.UseLineNumbers ? settings.LineNumberStart : 0;
            string FormatG(string code)
            {
                if (!settings.UsePaddedGCodes)
                    return code;
                if (code.Length >= 2 && code[0] == 'G')
                {
                    if (int.TryParse(code.Substring(1), out var n))
                        return $"G{n:00}";
                }
                return code;
            }

            var g0 = FormatG("G0");
            var g1 = FormatG("G1");

            void AddLine(string code)
            {
                if (settings.UseLineNumbers)
                {
                    program.Lines.Add($"N{lineNumber} {code}");
                    lineNumber += settings.LineNumberStep;
                }
                else
                {
                    program.Lines.Add(code);
                }
            }

            AddLine("(Generated by GCodeGenerator)");

            foreach (var operation in operations)
            {
                if (settings.UseComments)
                    AddLine($"({operation.Name}: {operation.GetDescription()})");

                if (operation is DrillPointsOperation drill)
                {
                    var fmt = $"0.{new string('#', drill.Decimals)}";
                    var culture = CultureInfo.InvariantCulture;

                    foreach (var hole in drill.Holes)
                    {
                        // 1. Move to safe Z first, then to XY of the hole using rapid feed.
                        AddLine($"{g0} Z{drill.SafeZBetweenHoles.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                        AddLine($"{g0} X{hole.X.ToString(fmt, culture)} Y{hole.Y.ToString(fmt, culture)} F{drill.FeedXYRapid.ToString(fmt, culture)}");

                        // 2. Peck drilling by StepDepth until TotalDepth is reached.
                        var currentZ = hole.Z;
                        var finalZ = hole.Z - hole.TotalDepth;

                        while (currentZ > finalZ)
                        {
                            var nextZ = currentZ - hole.StepDepth;
                            if (nextZ < finalZ)
                                nextZ = finalZ;

                            // Rapid to current start Z, then work feed to next depth.
                            AddLine($"{g0} Z{currentZ.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                            AddLine($"{g1} Z{nextZ.ToString(fmt, culture)} F{hole.FeedZWork.ToString(fmt, culture)}");

                            currentZ = nextZ;

                            // Retract only if we have more depth to drill.
                            if (currentZ > finalZ)
                                AddLine($"{g0} Z{hole.RetractHeight.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                        }

                        // 3. After finishing the hole, move back to safe Z for travel to next hole.
                        AddLine($"{g0} Z{drill.SafeZBetweenHoles.ToString(fmt, culture)} F{hole.FeedZRapid.ToString(fmt, culture)}");
                    }
                }
                else
                {
                    // Stub for other types
                    AddLine($"; TODO: implement {operation.Type} generation");
                }
            }

            AddLine("M30");
            return program;
        }
    }
}


